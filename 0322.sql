--테이블복제 생성
CREATE TABLE dept_temp
as(SELECT * FROM dept);

SELECT *
FROM dept

--데이터 입력
INSERT INTO DEPT_temp (deptno,dname,loc)
VALUES (50,'database','seoul')

INSERT INTO DEPT_temp (deptno,dname,loc)
VALUES (50,'kb','yeido')

COMMIT;

INSERT INTO DEPT_temp (deptno,dname,loc)
VALUES (70,'alpa','sungsoo')

INSERT INTO DEPT_temp (deptno,dname,loc)
VALUES (80,'MZCO','MIGOOK')

INSERT INTO DEPT_temp
VALUES (80,'HANKOOK','KOREA')

INSERT INTO DEPT_temp (deptno)
VALUES (1)

SELECT *
FROM dept_temp

-- 컬럼값만 복사해서 새로운 테이블을 생성
-- WHERE 조건값에 1 <> 1
CREATE TABLE EMP_temp
AS SELECT * FROM EMP
WHERE 1<>1;

SELECT *
FROM EMP_temp

COMMIT

ALTER TABLE EMP_temp DROP COLUMN TEST1

SELECT *
FROM EMP_temp

COMMIT

INSERT INTO EMP_temp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)
VALUES(9999,'유성진','CEO',NULL,TO_DATE('2023/01/01','YYYY/MM/DD'),6000,500,10)

INSERT INTO EMP_temp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)
VALUES(1111,'이순신','CFO',9999,TO_DATE('07/30/2023','MM/DD/YYYY'),4800,NULL,20)

INSERT INTO EMP_temp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)
VALUES(2222,'심청이','MANAGER',9999,SYSDATE,4000,NULL,20)

--기존에 있던 EMP 테이블의 특정 조건을 충족하는 인스턴스를 가져옴
INSERT INTO EMP_temp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)
 SELECT E.EMPNO 
 		,E.ENAME 
 		,E.JOB
 		,E.MGR 
 		,E.HIREDATE 
 		,E.SAL 
 		,E.COMM 
 		,E.DEPTNO 
 FROM EMP e ,SALGRADE s 
 WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL 
 	   AND S.GRADE = 1
;

--UPDATE [테이블명] SET 문 : 필터된 데이에 대해서 레코드 값 수정,WHERE를 하지 않으면 전체 인스턴스의 값이 변경됨
CREATE TABLE dept_temp2
as(SELECT * FROM dept)
;

UPDATE DEPT_TEMP2
 SET LOC = 'SEOUL'
 WHERE DEPTNO = 10
 ;

UPDATE DEPT_TEMP2
 SET DNAME ='DATABASE'
 	 ,LOC = 'SEOUL'
 WHERE DEPTNO = 40
 ;

SELECT *
FROM dept_temp2
WHERE ROWNUM <=10
;

COMMIT

/*
서브쿼리를 사용하여 UPDATE
*/
UPDATE DEPT_TEMP2
 SET (DNAME,LOC) = 
 (SELECT DNAME,LOC
	FROM DEPT
	WHERE DEPTNO = 40)
 WHERE DEPTNO = 40
;
ROLLBACK; --직전 COMMIT으로 원복

SELECT *
FROM dept_temp2

COMMIT;
---------------------------------------------
SELECT *
FROM EMP_TEMP2
;
CREATE TABLE EMP_TEMP2 AS(SELECT * FROM EMP);

COMMIT;

DELETE FROM EMP_TEMP2
	WHERE JOB='MANAGER'
;

ROLLBACK; --직전 COMMIT으로 원복
COMMIT;

DELETE FROM EMP_TEMP2
	WHERE EMPNO IN (SELECT E.EMPNO
					  FROM EMP_TEMP2 E, SALGRADE s 
					  WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL 
					  	AND S.GRADE = 3
					  	AND DEPTNO = 30)
					  	
SELECT *
FROM EMP_TEMP2
;

/*CREATE 문을 정의 : 기존에 없는 테이블 구조를 생성
데이터는 없고, 테이블의 컬럼과 데이터 타입, 제약 조건 등의 구조를 생성*/

CREATE TABLE EMP_NEW
(
	EMPNO NUMBER(4)
	,ENAME VARCHAR(10)
	,JOB VARCHAR(10)
	,MGR NUMBER(4)
	,HIREDATE DATE
	,SALGRADE NUMBER(7,2)
	,COMM NUMBER(7,2)
	,DEPTNO NUMBER(2)
)
;
/*테이블마다 자동 부여 되는 칼럼인 ROWNUM 사용법 , WHERE ROWNUM = 5로 조건을 주면 에러. 특정 행을 조회하는 게 아니라
범위를 조회한다고 이해하면됨*/
SELECT *
FROM EMP_NEW
WHERE ROWNUM <= 5
;

ALTER TABLE EMP_NEW 
ADD HP VARCHAR(20)
;

ALTER TABLE EMP_NEW 
RENAME COLUMN HP TO TEL_NO --잘 못된 컬럼 명 HP를 고객 전화 번호 컬럼 TEL_NO로 수정

COMMIT

ALTER TABLE EMP_NEW --새로 인수한 회사 직원 관리 테이블 수정
  MODIFY EMPNO NUMBER(5)
  
ALTER TABLE EMP_NEW
DROP COLUMN TEL_NO
 
/*SEQUENCE 일련번호를 생성하여 테이블 관리를 편리하게 하고자함
 * SEQUENCE 가 지정된 칼럼은 순서대로 채번이 가능함*/

CREATE SEQUENCE SEQ_DEPTNO
	INCREMENT BY 1
	START WITH 1
	MAXVALUE 999
	MINVALUE 1
	NOCYCLE
	NOCACHE;

DROP SEQUENCE SEQ_DEPTNO

INSERT INTO DEPT_TEMP2 (DEPTNO,DNAME,LOC)
VALUES (SEQ_DEPTNO.NEXTVAL,'DATABASE','SEOUL')
;
INSERT INTO DEPT_TEMP2 (DEPTNO,DNAME,LOC)
VALUES (SEQ_DEPTNO.NEXTVAL,'WEN','BUSAN')
;
INSERT INTO DEPT_TEMP2 (DEPTNO,DNAME,LOC)
VALUES (SEQ_DEPTNO.NEXTVAL,'MOBILE','SEUNGSOO')
;
INSERT INTO DEPT_TEMP2 (DEPTNO,DNAME,LOC)
VALUES (SEQ_DEPTNO.NEXTVAL,'MARKET','YEIDO')
;

SELECT *
FROM DEPT_TEMP2

/*
제약조건(CONSTRAINT) 지정
테이블을 생성할 때 , 테입즐 컬럼별 제약 조건을 설정
자주사용되는 제약조건
PK
FK
NOT NULL
UNIQUE
*/

CREATE TABLE LOGIN
(
	LOG_ID   VARCHAR2(20) NOT NULL
	,LOG_PWD VARCHAR2(20) NOT NULL
	,TEL 	 VARCHAR2(20) NOT NULL
)
;

INSERT INTO LOGIN(LOG_ID,LOG_PWD,TEL)
VALUES ('TEST01','1234','01011112222')

SELECT * FROM LOGIN;



ALTER TABLE LOGIN  
 MODIFY TEL NOT NULL
 
UPDATE LOGIN
SET TEL = '01033335444'
WHERE LOG_ID = 'TEST01'

/*오라클 DBMS가 사용자를 위해 만들어 놓은 제약조건 설정값 테이블*/
SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'LOGIN'
;

ALTER TABLE LOGIN  
 MODIFY (TEL CONSTRAINT TEL_NN NOT NULL)
 

ALTER TABLE LOGIN
DROP CONSTRAINT SYS_C007040
;

/*UNIQUE 키워드 사용*/

CREATE TABLE LOGIN_UNIQUE
(
	LOG_ID   VARCHAR2(20) UNIQUE
	,LOG_PWD VARCHAR2(20) NOT NULL
	,TEL 	 VARCHAR2(20) 
)
;
SELECT * FROM LOGIN_UNIQUE;

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'LOG_UNIQUE'

INSERT INTO LOGIN_UNIQUE(LOG_ID,LOG_PWD,TEL)
VALUES ('1111','1234','01011112222')

COMMIT

UPDATE LOGIN_UNIQUE 
SET LOG_ID = 'TEST_ID_NEW'
WHERE LOG_ID IS NULL
;
--TEL은 NULL은 가능하고 중복되지 않도록 유니크 제약 조건 설정함
ALTER TABLE LOGIN_UNIQUE MODIFY(TEL UNIQUE);


--PK 넣기
CREATE TABLE LOG_PK
(
LOG_ID VARCHAR2(20) PRIMARY KEY
,LOG_PWD VARCHAR2(20) NOT NULL
,TEL VARCHAR2(20)
)
;

INSERT INTO LOG_PK(LOG_ID,LOG_PWD,TEL)
VALUES('PK01','PWD01','01031120771')

--기존고객의 ID와 동일값 입력으로 에러발생
INSERT INTO LOG_PK(LOG_ID,LOG_PWD,TEL)
VALUES('PK01','PWD01','01031120771')

--PK값은 ID를 NULL로 입력으로 인한 에러 발생
INSERT INTO LOG_PK(LOG_ID,LOG_PWD,TEL)
VALUES(NULL,'PWD01','01031120771')

INSERT INTO LOG_PK(LOG_ID,LOG_PWD,TEL)
VALUES('PK02','PWD01','01031120771')

SELECT * FROM EMP_TEMP;

--존재하지 않는 부서번호를 EMP_TEMP 테이블에 입력을 시도
INSERT INTO EMP_TEMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)
VALUES(3333,'하하하','LOOPANG',9999,SYSDATE,1000,NULL,99)

--존재하지 않는 부서번호를 EMP 테이블에 입력을 시도
INSERT INTO EMP_TEMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)
VALUES(3333,'하하하','LOOPANG',9999,SYSDATE,1000,NULL,99)

SELECT * FROM EMP_TEMP

/*INDEX : 빠른 검색을 위한 색인 
장점:순식간에 원하는 값을 찾아줌
단점:입력과 출력이 잦은 경우 ,인덱스가 설정된 테이블의 속도가 저하된다*/

CREATE INDEX IDX_EMP_JOB
ON EMP(JOB)
;

--설정한 인덱스 출력
SELECT *
FROM USER_INDEXES
WHERE TABLE_NAME IN('EMP','DEPT')

/*VIEW : 테이블을 편리하게 사용하기 위한 목적으로 생성하는 가상 테이블*/
CREATE VIEW VW_EMP_20 
AS (SELECT EMPNO,ENAME,JOB,DEPTNO FROM EMP WHERE DEPTNO = 20)
;

SELECT *
FROM USER_VIEWS
WHERE VIEW_NAME = 'VW_EMP_20'
;

/*ROWNUM 사용 : 상위 N개를 출력하기 위해 사용하며
컬럼에 ROWNUM  순번을 입력하여 사용할 수 있음*/
SELECT ROWNUM
	   ,E.*
FROM EMP e 
ORDER BY SAL DESC
;
/*인라인뷰:SQL문에서 일회성으로 사용하는 뷰
인라인에서 SAL을 큰순으로 정렬을 하고 인라인 바깥쪽에서 ROWNUM으로 출력을 해야 가장 SAL이 
많이 받는 사람 부터 출력됨(오라클은 TOP함수가 안되기때문에)*/

SELECT ROWNUM,E.*
FROM(SELECT * FROM EMP e ORDER BY SAL DESC) E;

SELECT ROWNUM,E.*
FROM(SELECT * FROM EMP e ORDER BY SAL DESC) E
WHERE ROWNUM <=5;

/*오라클 DBMS에서 관리하는 관리 테이블 리스트 출력*/
SELECT *
FROM DICT WHERE TABLE_NAME LIKE 'EMP'

SELECT* FROM DBA_TABLES

SELECT* FROM DBA_TABLES
WHERE USERNAME = 'SCOTT'

SELECT *
FROM DBA_USERS
WHERE USERNAME = 'SCOTT%'

