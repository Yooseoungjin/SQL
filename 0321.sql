-- 기본적인 내용이므로 숙지 할것 
-- [%  :  0개 이상의 문자를 나타낸다. (글자 수 제한 X)]
-- [_  :  한 개의 문자를 나타낸다. (글자 수 제한 O) ]

--S 로 시작하는 모든 이름
select ENAME from emp where ENAME like 'S%';
--S 를 포함하는 모든 이름
select ENAME from emp where ENAME  like '%S%';
--두 번째 글자가 S 인 모든 이름
select ENAME from emp where ENAME  like '_S%' OR ENAME  like '_O%';
--S 로 시작하는 다섯 글자 이름 F로 시작하는 네글자 이름
select ENAME from emp where ENAME  like 'S____' OR ENAME  like 'F___';
--두 번째 글자가 I 인 네 글자 이름
select ENAME from emp where ENAME  like '_I__'; 

---------------------------------
SELECT AVG(SAL), '10' AS dno
FROM EMP
WHERE DEPTNO = 10
UNION ALL
SELECT AVG(SAL), '20' AS dno
FROM EMP
WHERE DEPTNO = 20
UNION ALL
SELECT AVG(SAL), '30' AS dno
FROM EMP
WHERE DEPTNO = 30
;
--GROUP BY
SELECT DEPTNO,JOB
, COUNT(SAL) 
, AVG(SAL +NVL(COMM,0)) AS AVG
, MAX(SAL +NVL(COMM,0)) AS MAX
, MIN(SAL +NVL(COMM,0)) AS MIN
, SUM(SAL +NVL(COMM,0)) AS SUM
FROM EMP
GROUP BY DEPTNO ,JOB
ORDER BY DEPTNO,JOB
;
--JOIN 키워드 : 테이블 정규화로 분할 된 테이블 컬럼을 합치는 작업

--아래는 카티시안 곱 발생으로 오류임(오류라기 보다 써먹을곳이 없다?가 맞을듯)
SELECT *
FROM EMP, DEPT
ORDER BY EMPNO,LOC
;
--아래는 카티시안 곱 발생으로 오류임
SELECT *
FROM EMP e, DEPT d
WHERE e.ENAME = 'MILLER'
ORDER BY EMPNO 

--INNER - JOIN 교집합 컬럼 연결
SELECT *
FROM EMP E ,DEPT D 
WHERE E.DEPTNO =D.DEPTNO 
ORDER BY E.EMPNO 

SELECT *
FROM EMP E JOIN DEPT D 
ON E.DEPTNO =D.DEPTNO
ORDER BY E.EMPNO 

--아래 처럼USING 사용시 사용된 컬럼인 DEPTNO는 사라짐
SELECT *
FROM EMP E JOIN DEPT D 
USING(DEPTNO)
ORDER BY E.EMPNO

SELECT D.DNAME 
,E.JOB 
,AVG(E.SAL) 
,SUM(E.SAL)
,MAX(E.SAL)
,MIN(E.SAL)
,COUNT(E.SAL)
FROM EMP E, DEPT D 
WHERE E.DEPTNO = D.DEPTNO
AND E.SAL <2000
GROUP BY D.DNAME , E.JOB ;

SELECT E.ENAME 
,S.GRADE 
,E.DEPTNO 
,E.SAL 
,E.JOB 
FROM EMP e ,SALGRADE s 
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL 

SELECT S.GRADE 
,COUNT(E.ENAME) AS EMP_CNT
FROM EMP e ,SALGRADE s 
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL 
GROUP BY S.GRADE
ORDER BY EMP_CNT

SELECT E.ENAME 
,E.DEPTNO 
,E.JOB 
,S.GRADE 
,E.SAL 
FROM EMP e ,SALGRADE s 
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL 

SELECT S.GRADE
,COUNT(E.ENAME) AS EMP_CNT
FROM EMP e ,SALGRADE s 
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL 
GROUP BY S.GRADE 
ORDER BY EMP_CNT DESC 


SELECT e1.EMPNO 
,e1.ENAME 
,e2.MGR 
,e2.ENAME
FROM EMP e1 ,EMP e2
WHERE e1.EMPNO = e2.MGR ;

-- 칼럼 추가
ALTER TABLE EMP ADD TEST1 CHAR(10);

SELECT *
FROM EMP e ,DEPT d 
WHERE E.DEPTNO =D.DEPTNO 

SELECT E1.EMPNO 
,E1.ENAME 
,E1.MGR 
,E2.EMPNO AS MRG_NO
,E2.ENAME AS MRG_NAME
FROM EMP e1, EMP e2
WHERE E1.MGR = E2.EMPNO(+) 

--LEFT-JOIN : 오라클 SQL활용, 왼쪽 테이블 값을 모두 가져오고, 
--JOIN하는 테이블에서 해당 되는 일부만 가져오기
SELECT E1.EMPNO 
,E1.ENAME 
,E1.MGR 
,E2.EMPNO AS MRG_NO
,E2.ENAME AS MRG_NAME
FROM EMP e1, EMP e2
WHERE E1.MGR = E2.EMPNO(+) 
;

--LEFT-JOIN 표준 SQL을 활용하여 매니저와 담당 직원 정보를 출력
SELECT E1.EMPNO 
,E1.ENAME 
,E1.MGR 
,E2.EMPNO AS MRG_NO
,E2.ENAME AS MRG_NAME
FROM EMP e1 LEFT OUTER JOIN EMP E2
ON E1.MGR = E2.EMPNO
;

--RIGHT JOIN : 오라클 SQL활용
SELECT E1.EMPNO 
,E1.ENAME 
,E1.MGR 
,E2.EMPNO AS MRG_NO
,E2.ENAME AS MRG_NAME
FROM EMP e1, EMP e2
WHERE E1.MGR(+) = E2.EMPNO
;

SELECT E1.EMPNO 
,E1.ENAME 
,E1.MGR 
,E2.EMPNO AS MRG_NO
,E2.ENAME AS MRG_NAME
FROM EMP e1 RIGHT OUTER JOIN EMP e2
ON E1.MGR = E2.EMPNO
;

SELECT E1.EMPNO 
,E1.ENAME 
,E1.MGR 
,E2.EMPNO AS MRG_NO
,E2.ENAME AS MRG_NAME
FROM EMP e1 FULL OUTER JOIN EMP e2
ON E1.MGR = E2.EMPNO
ORDER BY E1.EMPNO ;
;


SELECT 
D.DEPTNO 
,D.DNAME 
,E1.EMPNO 
,E1.ENAME 
,E1.MGR 
,E1.SAL 
,E1.DEPTNO 
,S.LOSAL 
,S.HISAL 
,S.GRADE 
,E2.EMPNO AS MGRNO
,E2.EMPNO AS MGRNAME
FROM EMP e1
-- 부점정보가 있는 테이블인 DEPTNO를 RIGHT JOIN을 해야 직원이 없는 부점도 출력이 된다.
RIGHT JOIN DEPT d ON E1.DEPTNO  = D.DEPTNO 
LEFT OUTER JOIN SALGRADE s  ON E1.SAL BETWEEN S.LOSAL AND S.HISAL 
LEFT OUTER JOIN EMP e2 ON E1.MGR =E2.EMPNO 
ORDER BY D.DEPTNO,E1.EMPNO
----------------------------------------------
SELECT 
D.DEPTNO 
,D.DNAME 
,E1.EMPNO 
,E1.ENAME 
,E1.MGR 
,E1.SAL 
,E1.DEPTNO
FROM EMP e1,DEPT d
WHERE E1.DEPTNO (+) = D.DEPTNO
----------------------------------------------
SELECT 
E1.EMPNO 
,E1.ENAME 
,E1.MGR 
,E1.SAL 
,E1.DEPTNO 
,S.LOSAL 
,S.HISAL 
,S.GRADE
FROM EMP e1 ,SALGRADE s 
WHERE E1.SAL BETWEEN S.LOSAL AND S.HISAL;

--계층형쿼리 만들기--
--실무상 필요할까? 굳이 계층형으로 만들 이유가 있을까?
--SQLD 시험에는 나옴
SELECT TO_CHAR(EMPNO) AS EMPNO 
,TO_CHAR(MGR) AS MGR_NO
,LEVEL 
,LPAD(' ',3*(LEVEL-1))||ENAME AS CONNECTBY
FROM EMP
START WITH MGR IS NULL
CONNECT BY PRIOR EMPNO = MGR;

--서브쿼리 : 블레이크보다 SAL이 더 많은 사람 추출
SELECT ENAME , SAL
FROM EMP e 
WHERE SAL >(SELECT SAL FROM EMP WHERE ENAME ='BLAKE');

SELECT DEPTNO ,ENAME , SAL
FROM EMP e 
WHERE SAL IN(SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);

SELECT DEPTNO ,ENAME , SAL
FROM EMP e 
WHERE SAL > (SELECT AVG(SAL) FROM EMP GROUP BY DEPTNO);

SELECT AVG(SAL) FROM EMP GROUP BY DEPTNO

SELECT DEPTNO,MAX(SAL)
FROM EMP
GROUP BY DEPTNO 
ORDER BY DEPTNO
;

SELECT *
FROM EMP
WHERE SAL = ANY(SUB_QUERY)
;

SELECT MIN(SAL),MAX(SAL)
FROM EMP
WHERE DEPTNO = 30

SELECT *
FROM EMP
WHERE SAL < ANY (SELECT SAL FROM EMP WHERE DEPTNO = 30)
ORDER BY SAL
;
--각 부서 안에서 가장 급여가 큰(작은) 직원 추출 하는법. 이건 많이 쓰일듯(데이터 분석시)
SELECT *
FROM EMP
WHERE SAL = ANY (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO)
ORDER BY SAL
;
SELECT *
FROM EMP
WHERE SAL = ANY (SELECT MIN(SAL) FROM EMP GROUP BY DEPTNO)
ORDER BY SAL
;

--위에 꺼랑 결과값이 같게 나오는데????? 어느게 더 유용할지?
SELECT *
FROM EMP
WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO)
;

-- FROM 절에 사용되는 서브 쿼리
SELECT
E.EMPNO
, E.ENAME
, E.DEPTNO
, D.DNAME
, D.LOC
FROM (SELECT * FROM EMP WHERE DEPTNO = 10 ) E
    ,(SELECT * FROM DEPT) D -- 이 행은 조건을 주지 않으면 DEPT D로 해도 됨 WHERE 줄것을 대비해서 작성해 놓으면 편할 듯
WHERE E.DEPTNO = D.DEPTNO

--WHIT 절 사용으로 간단한 서브쿼리
--사용해보니 WITH 구분으로 특정 테이블에 대해서 조건을 붙이고 셀렉이후를 간편히 사용할때 편할듯?
WITH E AS(SELECT * FROM EMP WHERE DEPTNO = 20),
	 D AS(SELECT * FROM DEPT),
	 S AS(SELECT * FROM SALGRADE)
	 
SELECT
E.EMPNO
, E.ENAME
, E.DEPTNO
, D.DNAME
, D.LOC
, S.GRADE
FROM E,D,S
WHERE E.DEPTNO = D.DEPTNO
AND E.SAL BETWEEN S.LOSAL AND S.HISAL
;
--------DDL---------
-- 테이블 복제
CREATE TABLE ALPACO_EMP
AS SELECT * FROM EMP;
--------------------------
SELECT *
FROM ALPACO_EMP

--테이블 드랍 : 세상에서 없애 버림. 흔적도 남지 않고 복구 불가 및 메모리 초기화
DROP TABLE ALPACO_EMP

--테이블 데이터 삭제 :  데이터만 삭제, 오토커밋 안됨, DB는 그대로 유지
DELETE FROM ALPACO_EMP

--드랍과 테이블의 중간 단계, 최초 테이블 생성시로 데이터 초기화, 흔적(로그)는 남지 않음
TRUNCATE TABLE ALPACO_EMP

--칼럼 드랍
ALTER TABLE ALPACO_EMP DROP COLUMN TEST1